çµè«–ã‹ã‚‰ï¼šã‚„ã‚‹ä¾¡å€¤ã¯å¤§ã„ã«ã‚ã‚Šã¾ã™ã€‚
YFCC100Mï¼ˆ= Flickrã®CCç”»åƒãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ï¼‰ã‚’æ¯é›†å›£ã¨ã—ã¦ â€œæ–™ç†ã‚µãƒ–ã‚»ãƒƒãƒˆâ€ ã‚’ä½œã‚Šã€Flickr API ã‹ã‚‰ EXIFï¼ˆç‰¹ã« FocalLengthIn35mmFormat ã¨ ExifImageWidth/Heightï¼‰ã‚’å–å¾—ã—ã¦ã‚«ãƒ¡ãƒ©å†…éƒ¨ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ 
ğ¾
K ã‚’å³å¯†ã«ç®—å‡º â†’ æ—¢å­˜ã®ä½“ç©æ¨å®šãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã«æŠ•å…¥ã€ã¨ã„ã†æµã‚Œã¯ã€K ã® â€œå½“ã¦æ¨é‡â€ ã‚„ 
ğ¾
K ã‚¹ã‚±ãƒ¼ãƒ«ä¿‚æ•°èª¿æ•´ã‚’å»ƒã—ã€å†ç¾æ€§ã®é«˜ã„è©•ä¾¡ã‚’å¯èƒ½ã«ã—ã¾ã™ã€‚
æ ¹æ‹ ï¼šYFCC100M ã¯ Flickr ç”±æ¥ã®å¤§è¦æ¨¡ CC ç”»åƒã‚³ãƒ¼ãƒ‘ã‚¹ã§ã€ã‚«ãƒ¡ãƒ©æ©Ÿç¨®æƒ…å ±ç­‰ã®ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ãŒå«ã¾ã‚Œã€å¤§ãã„è§£åƒåº¦ã®ç”»åƒã¯ Flickr å´ã‹ã‚‰å–å¾—ã§ãã¾ã™ï¼ˆS3ãƒŸãƒ©ãƒ¼ã¯é•·è¾º500pxã§ EXIF ã¯åŸºæœ¬å«ã¾ã‚Œãªã„ãŸã‚ã€Flickr API ä½µç”¨ãŒå‰æï¼‰ã€‚
The Multimedia Commons Initiative
+1
 ã¾ãŸã€Flickr API flickr.photos.getExif ã§ EXIF ã® 35mm æ›ç®—ç„¦ç‚¹è·é›¢ãªã©ã‚’å–å¾—ã§ãã¾ã™ã€‚

ä»¥ä¸‹ã€å®Ÿé‹ç”¨ã§ãã‚‹å®Œå…¨ãªå®Ÿè£…ãƒ—ãƒ©ãƒ³ï¼ˆã‚µãƒ³ãƒ—ãƒ«ã‚³ãƒ¼ãƒ‰ä»˜ãï¼‰ã§ã™ã€‚
ï¼ˆâ€» Nutrition5k ã§å¾®èª¿æ•´æ¸ˆã¿ã® Depth Anything V2ï¼ˆMetricï¼‰or UniDepth v2 ã©ã¡ã‚‰ã«ã‚‚é©ç”¨å¯èƒ½ï¼‰

å…¨ä½“æ–¹é‡ï¼ˆè¦ç‚¹ï¼‰

ãƒ‡ãƒ¼ã‚¿å–å¾—ï¼ˆæ–™ç†ã‚µãƒ–ã‚»ãƒƒãƒˆåŒ–ï¼‰

å…¥å£ã¯2é€šã‚Šï¼š

A. Flickr API ã§ CC æ–™ç†ç”»åƒã‚’ç›´æ¥åé›†ï¼ˆæ¨å¥¨ï¼æœ€çŸ­ï¼‰
â†’ ã‚¿ã‚°/ãƒ†ã‚­ã‚¹ãƒˆï¼ˆ"food", "meal", "dish", "ramen", "bento", etc.ï¼‰ã§æ¤œç´¢ã—ã€ãƒ©ã‚¤ã‚»ãƒ³ã‚¹ã‚’ CC ç³»ã«é™å®šã€å…¬é–‹ EXIF ã‚’æŒã¤å†™çœŸã ã‘æ¡ç”¨ã€‚

B. YFCC100M ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ï¼ˆWebscope/mmcommonsï¼‰ã‚’ãƒ­ãƒ¼ã‚«ãƒ«ã§ãƒ•ã‚£ãƒ«ã‚¿ â†’ Flickr Photo ID ã‚’ã‚­ãƒ¼ã« Flickr API ã§ EXIF ã‚’å¼•ãï¼ˆS3ã®500pxç”»åƒã¯ EXIF ãŒç„¡ã„æƒ³å®šã®ãŸã‚ API ä½µç”¨ãŒå‰æï¼‰ã€‚
The Multimedia Commons Initiative

EXIF â†’ å†…éƒ¨ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ 
ğ¾
K ã®å³å¯†è¨ˆç®—

EXIF ãŒ FocalLengthIn35mmFormatï¼ˆ= 35mmæ›ç®—ç„¦ç‚¹è·é›¢, å˜ä½ mmï¼‰ã¨ ExifImageWidth/Height ã‚’æŒã¤ã‚±ãƒ¼ã‚¹ã‚’ â€œåˆæ ¼â€ ã¨ã™ã‚‹ã€‚

æ¬¡ã§ å³å¯†ã« fx, fy ã‚’ç®—å‡ºï¼ˆ35mm æ¨ª36mmãƒ»ç¸¦24mmã®è¦–é‡è§’ç­‰ä¾¡å®šç¾©ã‹ã‚‰å°å‡ºï¼‰ï¼š

ğ‘“
ğ‘¥
(
orig
)
=
ğ‘Š
orig
â‹…
ğ‘“
35
36
,
ğ‘“
ğ‘¦
(
orig
)
=
ğ»
orig
â‹…
ğ‘“
35
24
f
x
(orig)
	â€‹

=W
orig
	â€‹

â‹…
36
f
35
	â€‹

	â€‹

,f
y
(orig)
	â€‹

=H
orig
	â€‹

â‹…
24
f
35
	â€‹

	â€‹


ç”»åƒã‚’å‡¦ç†è§£åƒåº¦ 
(
ğ‘Š
proc
,
ğ»
proc
)
(W
proc
	â€‹

,H
proc
	â€‹

) ã¸ãƒªã‚µã‚¤ã‚ºã™ã‚‹å ´åˆã¯

ğ‘“
ğ‘¥
=
ğ‘“
ğ‘¥
(
orig
)
â‹…
ğ‘Š
proc
ğ‘Š
orig
,
ğ‘“
ğ‘¦
=
ğ‘“
ğ‘¦
(
orig
)
â‹…
ğ»
proc
ğ»
orig
,
ğ‘
ğ‘¥
=
ğ‘Š
proc
2
,
Â 
ğ‘
ğ‘¦
=
ğ»
proc
2
f
x
	â€‹

=f
x
(orig)
	â€‹

â‹…
W
orig
	â€‹

W
proc
	â€‹

	â€‹

,f
y
	â€‹

=f
y
(orig)
	â€‹

â‹…
H
orig
	â€‹

H
proc
	â€‹

	â€‹

,c
x
	â€‹

=
2
W
proc
	â€‹

	â€‹

,Â c
y
	â€‹

=
2
H
proc
	â€‹

	â€‹


35mmæ›ç®—ãŒç„¡ã„ãŒ FocalLength(mm) ã¨ ã‚»ãƒ³ã‚µãƒ¼å¹…ãŒã‚ã‹ã‚‹å ´åˆã¯

Â 
ğ‘“
ğ‘¥
=
ğ‘Š
orig
â‹…
ğ‘“
mm
sensor_width(mm)
Â f
x
	â€‹

=W
orig
	â€‹

â‹…
sensor_width(mm)
f
mm
	â€‹

	â€‹

ï¼ˆåŒæ§˜ã« 
ğ‘“
ğ‘¦
f
y
	â€‹

ï¼‰
â†’ ã‚¹ãƒãƒ›ç­‰ã¯ã‚»ãƒ³ã‚µãƒ¼å¹…ã®ä¸ç¢ºå®šæ€§ãŒå¤§ãã„ã®ã§ã€æœ¬ä½œæ¥­ã§ã¯ FocalLengthIn35mmFormat ãŒã‚ã‚‹å€‹ä½“ã‚’å„ªå…ˆæ¡ç”¨ã€‚

æ·±åº¦ãƒ¢ãƒ‡ãƒ«ãƒ»ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³

æ¨è«–æ™‚ã¯ Depth Anything V2ï¼ˆMetricï¼‰ or UniDepth v2 ã‚’ä½¿ã„ï¼ˆã©ã¡ã‚‰ã§ã‚‚ï¼‰ã€EXIF ç”±æ¥ 
ğ¾
K ã‚’æ­£ã—ãã‚¹ã‚±ãƒ¼ãƒªãƒ³ã‚°ã—ã¦ä½¿ç”¨ã€‚

å¹³é¢æ¨å®šï¼ˆRANSACï¼‰â†’ é«˜ã•ãƒãƒƒãƒ— â†’ ãƒ”ã‚¯ã‚»ãƒ«é¢ç© 
ğ‘
pix
=
ğ‘
2
/
(
ğ‘“
ğ‘¥
ğ‘“
ğ‘¦
)
a
pix
	â€‹

=Z
2
/(f
x
	â€‹

f
y
	â€‹

) â†’ ãƒã‚¹ã‚¯ç©åˆ†ã§ä½“ç©ç®—å‡ºï¼ˆæ—¢å­˜å®Ÿè£…ã‚’ãã®ã¾ã¾åˆ©ç”¨å¯èƒ½ï¼‰ã€‚

è©•ä¾¡

ä½“ç©ã®çµ¶å¯¾çœŸå€¤ã¯ç„¡ã„ã®ã§ã€K ãŒ EXIF ç”±æ¥ã«ãªã£ãŸã“ã¨ã«ã‚ˆã‚‹ â€œã‚¹ã‚±ãƒ¼ãƒ«å®‰å®šåŒ–â€ ã‚’ä¸»ãŸã‚‹æŒ‡æ¨™ã«ã€‚

åŒä¸€ç”»åƒã§ EXIF 
ğ¾
K vs ãƒ’ãƒ¥ãƒ¼ãƒªã‚¹ãƒ†ã‚£ãƒƒã‚¯ 
ğ¾
K vs å­¦ç¿’æ¸ˆ
ğ¾
Kï¼ˆUniDepth æ¨å®šï¼‰ ã‚’æ¯”è¼ƒï¼ˆLå˜ä½ã®æš´ã‚ŒãŒåæŸã™ã‚‹ã¯ãšï¼‰ã€‚

ãƒ©ã‚¤ã‚»ãƒ³ã‚¹

YFCC100M / Flickr CC ã¯**å„ç”»åƒã® CC ãƒ©ã‚¤ã‚»ãƒ³ã‚¹éµå®ˆ & è¡¨ç¤ºï¼ˆå¸°å±ï¼‰**ãŒå¿…è¦ã€‚è«–æ–‡å¼•ç”¨ã¯ CACM è«–æ–‡ã‚’å‚ç…§ã€‚
The Multimedia Commons Initiative

mmcommons ãƒŸãƒ©ãƒ¼ã®ç”»åƒã¯ 500pxï¼ˆEXIFç„¡ã—ï¼‰ãªã®ã§ã€Flickr ã‹ã‚‰ã®å¤§ã‚µã‚¤ã‚ºå–å¾—ï¼‹API EXIF å–å¾—ãŒå®Ÿå‹™çš„ã€‚
The Multimedia Commons Initiative

å®Ÿè£…ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªï¼ˆè¿½åŠ ææ¡ˆï¼‰
qwen_bbx/
â”œâ”€ data/
â”‚   â””â”€ yfcc_food_exif/              # â† åé›†ã—ãŸãƒ¡ã‚¿/ç”»åƒ/K ã‚’ä¿å­˜
â”œâ”€ scripts/
â”‚   â”œâ”€ yfcc_search_and_exif.py      # Flickr APIã§æ–™ç†ç”»åƒæ¤œç´¢â†’EXIFå–å¾—â†’Kç®—å‡º
â”‚   â”œâ”€ yfcc_download_original.py    # Flickrã‹ã‚‰å¤§ãã„ã‚µã‚¤ã‚ºã‚’ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰
â”‚   â””â”€ run_volume_on_yfcc.py        # EXIF-Kã§ä½“ç©æ¨å®šï¼ˆæ—¢å­˜srcã‚’åˆ©ç”¨ï¼‰
â””â”€ src/
    â””â”€ ï¼ˆæ—¢å­˜ã® plane_fit.py / volume_estimator.py ãªã©ï¼‰

1) åé›† & EXIFâ†’K è¨ˆç®—ã‚¹ã‚¯ãƒªãƒ—ãƒˆ

å‰æï¼šç’°å¢ƒå¤‰æ•° FLICKR_API_KEY, FLICKR_API_SECRET ã‚’è¨­å®š
ä¾å­˜ï¼špip install requests python-dateutil

scripts/yfcc_search_and_exif.py

#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Flickr APIã§æ–™ç†ç”»åƒã‚’æ¤œç´¢ â†’ EXIFå–å¾— â†’ Kã‚’è¨ˆç®—ã—ãƒ¡ã‚¿JSONLã«ä¿å­˜
- 35mmæ›ç®—ç„¦ç‚¹è·é›¢(FocalLengthIn35mmFormat)ã¨ExifImageWidth/HeightãŒã‚ã‚‹å†™çœŸã®ã¿æ¡ç”¨
- å–å¾—çµæœã¯ data/yfcc_food_exif/meta.jsonl ã«1è¡Œ1ãƒ¬ã‚³ãƒ¼ãƒ‰ã§ä¿å­˜
"""
import os, json, time, math, re
import requests
from urllib.parse import urlencode

API_KEY = os.environ.get("FLICKR_API_KEY")
API_SECRET = os.environ.get("FLICKR_API_SECRET")
OUT_DIR = "data/yfcc_food_exif"
os.makedirs(OUT_DIR, exist_ok=True)
OUT_JSONL = os.path.join(OUT_DIR, "meta.jsonl")

SEARCH_TAGS = ["food", "meal", "dish", "bento", "noodles", "ramen", "sushi", "curry", "pasta", "salad"]
PER_TAG_MAX = 500  # ã¾ãšã¯æ‰‹é ƒãªè¦æ¨¡ã§
MIN_WIDTH = 640    # å°ã•ã™ãã‚‹ç”»åƒã¯é™¤å¤–

FLICKR_API = "https://www.flickr.com/services/rest/"

def flickr(method, **params):
    p = {
        "method": method,
        "api_key": API_KEY,
        "format": "json",
        "nojsoncallback": 1,
    }
    p.update(params)
    r = requests.get(FLICKR_API, params=p, timeout=30)
    r.raise_for_status()
    data = r.json()
    if data.get("stat") != "ok":
        raise RuntimeError(f"Flickr API error: {data}")
    return data

def search_photos(tag, page=1, per_page=250):
    # CCç³»ãƒ©ã‚¤ã‚»ãƒ³ã‚¹ã«é™å®šã—ãŸã„å ´åˆã¯ license= ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’æŒ‡å®šï¼ˆå¿…è¦ã«å¿œã˜ã¦ï¼‰
    # ä¾‹: license="1,2,3,4,5,6,9,10" ï¼ˆè©³ç´°ã¯ Flickr API ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã‚’å‚ç…§ï¼‰
    return flickr(
        "flickr.photos.search",
        tags=tag,
        tag_mode="all",
        content_type=1,   # photos
        media="photos",
        safe_search=1,
        sort="relevance",
        per_page=per_page,
        page=page,
        extras="url_o"    # ã‚ªãƒªã‚¸ãƒŠãƒ«URL/ã‚µã‚¤ã‚ºæƒ…å ±ãŒè¿”ã‚‹ã“ã¨ãŒã‚ã‚‹
    )

def get_exif(photo_id):
    return flickr("flickr.photos.getExif", photo_id=photo_id)

def get_sizes(photo_id):
    return flickr("flickr.photos.getSizes", photo_id=photo_id)

def parse_mm(s: str):
    # "28" or "28mm" ã®ä¸¡å¯¾å¿œ
    m = re.match(r"^\s*([0-9.]+)", str(s))
    return float(m.group(1)) if m else None

def pick_tag(exif, tag):
    # exif["photo"]["exif"] ã®é…åˆ—ã‹ã‚‰ tag="FocalLengthIn35mmFormat" ãªã©ã‚’æ‹¾ã†
    arr = exif.get("photo", {}).get("exif", [])
    for kv in arr:
        if kv.get("tag") == tag:
            raw = kv.get("raw", {})
            if isinstance(raw, dict):
                return raw.get("_content")
            return kv.get("raw")
    return None

def compute_intrinsics_from_exif(exif, proc_w, proc_h, fallback_w=None, fallback_h=None):
    """
    EXIFã‹ã‚‰ fx, fy, cx, cy ã‚’å³å¯†ç®—å‡ºï¼ˆ35mmæ›ç®—ãŒå‰æï¼‰
    fx_orig = W_orig * f35 / 36, fy_orig = H_orig * f35 / 24
    """
    f35s = pick_tag(exif, "FocalLengthIn35mmFormat")  # ä¾‹ "28" or "28mm"
    if not f35s: 
        return None
    f35 = parse_mm(f35s)

    w0s = pick_tag(exif, "ExifImageWidth")
    h0s = pick_tag(exif, "ExifImageHeight")
    if w0s and h0s:
        w0, h0 = int(w0s), int(h0s)
    else:
        # ç„¡ã„å ´åˆã¯ getSizes ã® "Original" ã‚’ä½¿ã†ï¼ˆãªã‘ã‚Œã°ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ç”»åƒã®å®Ÿå¯¸ã«ç­‰ã—ã„ï¼‰
        w0 = fallback_w
        h0 = fallback_h
        if not (w0 and h0):
            return None

    fx_orig = w0 * (f35 / 36.0)
    fy_orig = h0 * (f35 / 24.0)

    sx = proc_w / float(w0)
    sy = proc_h / float(h0)
    fx = fx_orig * sx
    fy = fy_orig * sy
    cx = proc_w / 2.0
    cy = proc_h / 2.0
    return {"fx": fx, "fy": fy, "cx": cx, "cy": cy, "f35": f35, "w0": w0, "h0": h0}

def main():
    if not API_KEY:
        raise SystemExit("Set FLICKR_API_KEY / FLICKR_API_SECRET")

    out = open(OUT_JSONL, "w", encoding="utf-8")
    seen = set()
    try:
        for tag in SEARCH_TAGS:
            collected = 0
            page = 1
            while collected < PER_TAG_MAX:
                data = search_photos(tag, page=page)
                photos = data.get("photos", {})
                items = photos.get("photo", [])
                if not items: break

                for p in items:
                    pid = p["id"]
                    if pid in seen: continue

                    # å¯èƒ½ãªã‚‰ã‚ªãƒªã‚¸ãƒŠãƒ«ã®æƒ³å®šå¹…ãƒ»é«˜ã•
                    orig_w = int(p.get("width_o", 0)) if p.get("width_o") else None
                    orig_h = int(p.get("height_o", 0)) if p.get("height_o") else None

                    # ã¾ãšã‚µã‚¤ã‚ºæƒ…å ±ã‚’è£œå®Œï¼ˆå¿…è¦ã§ã‚ã‚Œã°ï¼‰
                    if not orig_w or not orig_h:
                        try:
                            sz = get_sizes(pid)
                            sizes = sz.get("sizes", {}).get("size", [])
                            orig = next((s for s in sizes if s.get("label") == "Original"), None)
                            if orig:
                                orig_w = int(orig.get("width", 0))
                                orig_h = int(orig.get("height", 0))
                            else:
                                # æœ€å¤§ã‚µã‚¤ã‚ºã‚’ä»£ç”¨
                                if sizes:
                                    smax = sizes[-1]
                                    orig_w = int(smax.get("width", 0))
                                    orig_h = int(smax.get("height", 0))
                        except Exception:
                            pass

                    if not (orig_w and orig_h and orig_w >= MIN_WIDTH):
                        continue

                    # EXIFå–å¾—
                    try:
                        ex = get_exif(pid)
                    except Exception:
                        continue

                    # ã“ã“ã§ã¯ â€œå‡¦ç†è§£åƒåº¦=ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã«ä½¿ã†ã‚µã‚¤ã‚ºâ€ ã‚’ä»®ç½®ã
                    # å¾Œæ®µã®æ¨è«–ã§ processor ãŒåˆ¥è§£åƒåº¦ã¸å¤‰ãˆã‚‹å ´åˆã¯ã€ãã®å€ç‡ã§Kã‚’å†ã‚¹ã‚±ãƒ¼ãƒ«ã™ã‚‹
                    proc_w, proc_h = orig_w, orig_h
                    K = compute_intrinsics_from_exif(ex, proc_w, proc_h, fallback_w=orig_w, fallback_h=orig_h)
                    if not K: 
                        continue

                    rec = {
                        "photo_id": pid,
                        "title": p.get("title"),
                        "orig_w": orig_w, "orig_h": orig_h,
                        "proc_w": proc_w, "proc_h": proc_h,
                        "K": K,
                        "search_tag": tag
                    }
                    out.write(json.dumps(rec, ensure_ascii=False) + "\n")
                    seen.add(pid)
                    collected += 1

                page += 1
                if page > photos.get("pages", 1):
                    break
                time.sleep(0.5)  # APIè² è·æŠ‘åˆ¶
    finally:
        out.close()
    print(f"saved: {OUT_JSONL}")

if __name__ == "__main__":
    main()


ãƒã‚¤ãƒ³ãƒˆ

35mmæ›ç®— & ExifImageWidth/Height ãŒæƒã†å€‹ä½“ã®ã¿æ¡ç”¨ â†’ 
ğ¾
K ã‚’â€œç„¡è£œæ­£â€ã§ç¢ºå®šå¯ã€‚

å¾Œæ®µã§ HF Processor ãŒåˆ¥è§£åƒåº¦ã¸å¤‰ãˆã‚‹å ´åˆã€K ã‚’åŒå€ç‡ã§å†ã‚¹ã‚±ãƒ¼ãƒ«ã—ã¦ãã ã•ã„ï¼ˆæ¬¡ç« ã®æ¨è«–å´ã§å¯¾å¿œï¼‰ã€‚

2) ç”»åƒãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ï¼ˆä»»æ„ï¼‰

flickr.photos.getSizes ã®å¿œç­”ã‹ã‚‰ **"Original" ã‹ "Large"ï¼ˆä¾‹: 1024/1600/2048ï¼‰**ã® URL ã‚’ä½¿ã£ã¦ä¿å­˜ã€‚
ï¼ˆä¸Šã® get_sizes ã§ URL ã‚’æ‹¾ãˆã¾ã™ã€‚ä¿å­˜ã‚³ãƒ¼ãƒ‰ã¯å‰²æ„›ï¼‰

â€» mmcommons ã® S3 ãƒŸãƒ©ãƒ¼ã¯é•·è¾º500px & EXIFãªã—ã€‚Flickr å´ã‹ã‚‰å¤§ãã„ã‚µã‚¤ã‚ºã‚’å–å¾—ã™ã‚‹ã®ãŒå‰æã§ã™ã€‚
The Multimedia Commons Initiative

3) ä½“ç©æ¨å®šã®æ¨è«–ã‚¹ã‚¯ãƒªãƒ—ãƒˆï¼ˆEXIFâ€“K é©ç”¨ï¼‰

Depth Anything V2ï¼ˆMetricï¼‰ ã® HF Processor ã¯å†…éƒ¨ã§ãƒªã‚µã‚¤ã‚ºã—ã¾ã™ã€‚
â†’ å‡ºåŠ›æ·±åº¦ã‚µã‚¤ã‚ºã«åˆã‚ã›ã¦ K ã‚’ãã®å ´ã§å†ã‚¹ã‚±ãƒ¼ãƒ«ã™ã‚‹ã®ãŒæ­£è§£ã§ã™ï¼ˆï¼ãƒ’ãƒ¥ãƒ¼ãƒªã‚¹ãƒ†ã‚£ãƒƒã‚¯ãª K_scale ã¯ä¸è¦ï¼‰ã€‚

scripts/run_volume_on_yfcc.py

#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
EXIFç”±æ¥Kã§ä½“ç©æ¨å®šï¼ˆYFCC/Flickræ–™ç†ç”»åƒï¼‰
- meta.jsonlï¼ˆyfcc_search_and_exif.pyã®å‡ºåŠ›ï¼‰ã‚’èª­ã¿ã€ç”»åƒã‚’æ¨è«–
- Depth Anything V2(Metric) ã¾ãŸã¯ UniDepth v2 ã‚’è‡ªç”±ã«é¸æŠ
"""
import os, json, cv2, numpy as np
from PIL import Image
import torch
from transformers import AutoImageProcessor, AutoModelForDepthEstimation

# æ—¢å­˜ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ï¼ˆãƒ¦ãƒ¼ã‚¶ãƒ¼å®Ÿè£…ï¼‰ã‚’åˆ©ç”¨
import sys
sys.path.append("src")
from plane_fit import estimate_plane_from_depth
from volume_estimator import height_map_from_plane, pixel_area_map, integrate_volume

META_PATH = "data/yfcc_food_exif/meta.jsonl"
IMAGE_DIR = "data/yfcc_food_exif/images"  # ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰å…ˆï¼ˆä»»æ„ã®æ§‹æˆï¼‰
HF_MODEL = "depth-anything/Depth-Anything-V2-Metric-Indoor-Large-hf"

def rescale_K(K, in_size, out_size):
    """ç”»åƒã‚’ in_size(H,W) -> out_size(H,W) ã«å¤‰ãˆãŸã¨ãã®Kå†ã‚¹ã‚±ãƒ¼ãƒ«"""
    H0, W0 = in_size; H1, W1 = out_size
    sx, sy = W1 / W0, H1 / H0
    K2 = K.copy()
    K2[0,0] *= sx;  K2[1,1] *= sy
    K2[0,2] *= sx;  K2[1,2] *= sy
    return K2

@torch.no_grad()
def infer_depth_da2(img_pil, processor, model, device):
    inputs = processor(images=img_pil, return_tensors="pt")
    inputs = {k: v.to(device) for k, v in inputs.items()}
    out = model(**inputs)
    pred = out.predicted_depth
    if pred.dim() == 3: pred = pred.unsqueeze(1)   # [B,1,H,W]
    depth = pred[0,0].cpu().numpy()                # [H,W], meters
    H, W = depth.shape
    # processorãŒå®Ÿéš›ã«ä½¿ã£ãŸã‚µã‚¤ã‚ºã‚’å–å¾—ï¼ˆå…¥åŠ›ãƒ†ãƒ³ã‚½ãƒ«ã®ç©ºé–“ã‚µã‚¤ã‚ºï¼‰
    proc_h, proc_w = inputs["pixel_values"].shape[-2:]
    assert (proc_h, proc_w) == (H, W) or True  # å®Ÿè£…å·®ç•°å¸å
    return depth, (H, W)

def main():
    device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
    processor = AutoImageProcessor.from_pretrained(HF_MODEL)
    model = AutoModelForDepthEstimation.from_pretrained(HF_MODEL).to(device).eval()

    with open(META_PATH, "r", encoding="utf-8") as f:
        for ln in f:
            rec = json.loads(ln)
            pid = rec["photo_id"]
            img_path = os.path.join(IMAGE_DIR, f"{pid}.jpg")  # ä¿å­˜å‘½åã¯ä»»æ„
            if not os.path.exists(img_path):
                continue

            # ç”»åƒèª­è¾¼ï¼ˆPILï¼‰
            img_pil = Image.open(img_path).convert("RGB")
            W0, H0 = img_pil.size

            # æ·±åº¦æ¨è«–
            depth, (H, W) = infer_depth_da2(img_pil, processor, model, device)

            # EXIFç”±æ¥Kï¼ˆmetaã¯ â€œproc_w/h=origâ€ å‰æã§è¨˜éŒ²ã—ã¦ã„ã‚‹ï¼‰
            Kin = np.array([
                [rec["K"]["fx"], 0, rec["K"]["cx"]],
                [0, rec["K"]["fy"], rec["K"]["cy"]],
                [0, 0, 1.0]
            ], dtype=np.float64)
            # å®Ÿéš›ã®æ¨è«–è§£åƒåº¦(H,W)ã¸ã‚¹ã‚±ãƒ¼ãƒ«
            K = rescale_K(Kin, in_size=(rec["proc_h"], rec["proc_w"]), out_size=(H, W))

            # ãƒã‚¹ã‚¯ã¯ä»Šå›ã¯ç„¡ã—ï¼ˆå…¨ä½“/ä¸­å¿ƒé ˜åŸŸãªã©é©å®œï¼‰
            # â†’ æ—¢å­˜ã®SAM2ã§å¾—ãŸé£Ÿå“ãƒã‚¹ã‚¯ãŒã‚ã‚Œã°ã€ãã‚Œã‚’HÃ—Wã«ãƒªã‚µã‚¤ã‚ºã—ã¦ä½¿ã†
            # ã“ã“ã§ã¯ä¸­å¿ƒå††ãƒã‚¹ã‚¯ã®ä¾‹
            yy, xx = np.ogrid[:H, :W]
            cy, cx = H//2, W//2; r = min(H, W)//4
            mask = ((yy-cy)**2 + (xx-cx)**2) <= r*r
            masks = [mask]; labels = ["center"]

            # å¹³é¢æ¨å®šâ†’é«˜ã•
            n, d, pts = estimate_plane_from_depth(depth, K, masks, margin_px=40, dist_th=0.006, max_iters=2000)
            height = height_map_from_plane(pts, n, d, clip_negative=True)
            a_pix = pixel_area_map(depth, K)

            # ä½“ç©
            res = integrate_volume(height, a_pix, mask, conf=None, use_conf_weight=False)
            print(f"{pid}: volume={res['volume_mL']:.1f} mL, mean_h={res['height_mean_mm']:.1f} mm")

if __name__ == "__main__":
    main()


é‡è¦ãƒã‚¤ãƒ³ãƒˆ

K ã®å†ã‚¹ã‚±ãƒ¼ãƒ«ï¼šå…¥åŠ›ç”»åƒã‚µã‚¤ã‚º â†’ ãƒ¢ãƒ‡ãƒ«ãŒå®Ÿéš›ã«è¨ˆç®—ã—ãŸè§£åƒåº¦ ã«åˆã‚ã›ã¦ 
ğ‘“
ğ‘¥
,
ğ‘“
ğ‘¦
,
ğ‘
ğ‘¥
,
ğ‘
ğ‘¦
f
x
	â€‹

,f
y
	â€‹

,c
x
	â€‹

,c
y
	â€‹

 ã‚’ç·šå½¢ã‚¹ã‚±ãƒ¼ãƒ«ï¼ˆä¸Šè¨˜ rescale_Kï¼‰ã€‚

ä»¥é™ã® é€†æŠ•å½±ãƒ»ãƒ”ã‚¯ã‚»ãƒ«é¢ç©ãƒ»ä½“ç©ç©åˆ†ã¯æ—¢å­˜ã®æ­£ã—ã„å®Ÿè£…ã®ã¾ã¾ã§ OKã€‚

ã“ã‚Œã§ K_scale_factor ã®æ‰‹å½“ã¦ã¯å®Œå…¨ã«ä¸è¦ã«ãªã‚Šã¾ã™ã€‚

4) ä»£æ›¿ãƒ«ãƒ¼ãƒˆï¼ˆYFCC100M ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã‹ã‚‰ã®æŠ½å‡ºï¼‰

æ—¢ã« YFCC100M ã®ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ï¼ˆyfcc100m_datasetï¼‰ ã‚’ãŠæŒã¡ãªã‚‰ã€user_tags/machine_tags/title ã‚’æ­£è¦è¡¨ç¾ã§ãƒ•ã‚£ãƒ«ã‚¿ï¼ˆæ–™ç†èªå½™ï¼‰â†’ Photo ID ã‚’æŸã§å–ã‚Šå‡ºã— â†’ ä¸Šè¨˜ get_exif() ã‚’ Photo ID ã«å¯¾ã—ã¦ãƒãƒ«ã‚¯å®Ÿè¡Œã€ã¨ã„ã†æµã‚ŒãŒå®Ÿå‹™çš„ã§ã™ã€‚

mmcommons ã®ã€Œã¯ã˜ã‚ã‹ãŸã€ãƒšãƒ¼ã‚¸ã«ã‚³ã‚¢ãƒ»ãƒ‡ãƒ¼ã‚¿ã‚»ãƒƒãƒˆã®æ¡ˆå†…ã¨ã€ã‚ˆã‚Šå¤§ããªç”»åƒã¯ Flickr ã‹ã‚‰å–å¾—ã™ã‚‹æ—¨ã®æ³¨è¨˜ãŒã‚ã‚Šã¾ã™ã€‚
The Multimedia Commons Initiative

ç ”ç©¶ã§ã®å¼•ç”¨ã¯ CACM è«–æ–‡ï¼ˆThomee et al., 2016ï¼‰ã‚’ã”å‚ç…§ãã ã•ã„ã€‚
The Multimedia Commons Initiative

5) ã‚ˆãã‚ã‚‹è½ã¨ã—ç©´ã¨å¯¾ç­–

EXIF éå…¬é–‹ / æ¬ è½ï¼šgetExif ã¯ãƒ¦ãƒ¼ã‚¶ãƒ¼è¨­å®šã«ä¾å­˜ã™ã‚‹ãŸã‚ã€æ¬ è½å†™çœŸã¯ã‚¹ã‚­ãƒƒãƒ—ã€‚æ–™ç†ã‚¸ãƒ£ãƒ³ãƒ«ã¯ EXIF ä»˜ãã‚‚å¤šã„ãŒã€ååˆ†ãªå†—é•·åº¦ã‚’æŒã¤ï¼ˆæ•°åƒã€œæ•°ä¸‡æšè¦æ¨¡ã§é›†ã‚ã‚‹ï¼‰ã€‚

35mmæ›ç®—ãŒç„¡ã„ï¼šFocalLength(mm) ã ã‘ã§ã¯ã‚»ãƒ³ã‚µãƒ¼å¯¸æ³•ãŒå¿…è¦ã€‚ã‚¹ãƒãƒ›ã¯æ©Ÿç¨®å·®ã‚„è¤‡æ•°ã‚«ãƒ¡ãƒ©ã§èª¤å·®ãŒå¤§ãã„ã®ã§ã€å½“é¢ã¯ 35mmæ›ç®—ã®ã‚ã‚‹å†™çœŸã«é™å®šã™ã‚‹ã®ãŒå …å®Ÿã€‚

Orientationï¼ˆå›è»¢ï¼‰ï¼šExifImageWidth/Height ã¯å›è»¢è£œæ­£å‰ã®ã“ã¨ãŒã‚ã‚‹ãŸã‚ã€Flickr ã‚µã‚¤ã‚º APIï¼ˆgetSizesï¼‰ã§å®Ÿéš›ã«å–å¾—ã™ã‚‹ã‚µã‚¤ã‚ºã¨åˆã‚ã›ã¦ãŠãã®ãŒç„¡é›£ï¼ˆä¸Šè¨˜ã‚³ãƒ¼ãƒ‰ã§å¯¾å¿œï¼‰ã€‚

Processor ã®ãƒªã‚µã‚¤ã‚ºï¼šHF Processor ãŒå†…éƒ¨è§£åƒåº¦ã‚’å¤‰ãˆã‚‹ â†’ K ã®å†ã‚¹ã‚±ãƒ¼ãƒ«å¿…é ˆï¼ˆä¸Šè¨˜ rescale_Kï¼‰ã€‚

mmcommons S3 ã®500pxï¼šEXIF ãŒæŠœã‹ã‚Œã¦ã„ã‚‹ã®ã§Flickr API ã‚’å¿…ãšä½µç”¨ã€‚
The Multimedia Commons Initiative

æ³•çš„ï¼šå„ç”»åƒã® CC ãƒ©ã‚¤ã‚»ãƒ³ã‚¹è¡¨ç¤ºãƒ»å¸°å±ã‚’éµå®ˆã€‚YFCC100M ã®ä¸€èˆ¬çš„ãªå¼•ç”¨å…ˆã¯ CACM è«–æ–‡ã€‚
The Multimedia Commons Initiative

6) DAâ€‘V2 vs UniDepth v2ï¼ˆä»Šå›ã® â€œEXIFâ€“Kâ€ ã‚·ãƒŠã‚¸ãƒ¼ï¼‰

ãƒ¦ãƒ¼ã‚¶ãƒ¼æŠ•ç¨¿ã®æ–™ç†ç”»åƒã‚’å¯¾è±¡ã«ã€Œä¸€æšå…¥åŠ›ã§ä½“ç©ã€ã‚’å®‰å®šåŒ–ã•ã›ã‚‹ä¸»å› ã¯ã€
ğ¾
K ã®æ­£ç¢ºåŒ–ã§ã™ã€‚

ã—ãŸãŒã£ã¦ã€Metric DAâ€‘V2 ã‚’ Nutrition5k ã§å¾®èª¿æ•´ã—ãŸãƒ¢ãƒ‡ãƒ«ã§ã‚‚ã€EXIFâ€“K ã‚’ä½¿ãˆã°ä½“ç©ã®ã‚ªãƒ¼ãƒ€ãƒ¼å®‰å®šãŒè¦‹è¾¼ã‚ã¾ã™ã€‚

UniDepth v2 ã¯ç”»åƒã‹ã‚‰ 
ğ¾
K ã‚‚æ¨å®šã—ã¾ã™ãŒã€è¿‘æ¥ãƒ»ãƒ†ãƒ¼ãƒ–ãƒ«ãƒˆãƒƒãƒ—ã®åˆ†å¸ƒå¤–ã§ 
ğ¾
K ãŒå°ã•ãå‡ºã‚‹/ãƒ–ãƒ¬ã‚‹äº‹ä¾‹ãŒã‚ã‚Šã€EXIFâ€“K ã®æ–¹ãŒå …ç‰¢ã¨ã„ã†ã‚±ãƒ¼ã‚¹ãŒå¤šã„ã§ã™ï¼ˆä»Šå›ã®æ–¹é‡ã¯ã©ã¡ã‚‰ã®ãƒ¢ãƒ‡ãƒ«ã§ã‚‚æœ‰åŠ¹ï¼‰ã€‚

7) æœ€çµ‚ãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆï¼ˆé‹ç”¨ã® â€œå®Œæˆå½¢â€ï¼‰

åé›†ï¼šFlickr API ã§ æ–™ç†ã‚¿ã‚°æ¤œç´¢ â†’ EXIF å–å¾— â†’ æ–™ç†ã‚µãƒ–ã‚»ãƒƒãƒˆã‚’ JSONL ã«ä¿ç®¡ã€‚

ç”»åƒï¼šgetSizes ã§é©åˆ‡ãªã‚µã‚¤ã‚º URL ã‚’å¾—ã¦ä¿å­˜ã€‚

ğ¾
K è¨ˆç®—ï¼š35mmæ›ç®— + ExifImageWidth/Height â†’ 
ğ‘“
ğ‘¥
,
ğ‘“
ğ‘¦
,
ğ‘
ğ‘¥
,
ğ‘
ğ‘¦
f
x
	â€‹

,f
y
	â€‹

,c
x
	â€‹

,c
y
	â€‹

ã€‚

æ¨è«–ï¼šProcessor ã®å‡ºåŠ›è§£åƒåº¦ã« 
ğ¾
K ã‚’å†ã‚¹ã‚±ãƒ¼ãƒ«ã€‚

ä½“ç©ï¼šæ—¢å­˜ã® RANSAC å¹³é¢ â†’ é«˜ã• â†’ 
ğ‘
pix
=
ğ‘
2
/
(
ğ‘“
ğ‘¥
ğ‘“
ğ‘¦
)
a
pix
	â€‹

=Z
2
/(f
x
	â€‹

f
y
	â€‹

) â†’ ãƒã‚¹ã‚¯ç©åˆ†ã€‚

æ¯”è¼ƒï¼šEXIFâ€“K vs æ—§ãƒ’ãƒ¥ãƒ¼ãƒªã‚¹ãƒ†ã‚£ãƒƒã‚¯â€“Kï¼ˆor UniDepth æ¨å®šâ€“Kï¼‰ã§ä½“ç©ã®å®‰å®šæ€§/å¦¥å½“ãƒ¬ãƒ³ã‚¸ã‚’æ¯”è¼ƒã€‚

å‚è€ƒï¼ˆä¸€æ¬¡æƒ…å ±ï¼‰

Multimedia Commonsï¼ˆYFCC100M ã‚¬ã‚¤ãƒ‰ï¼‰ï¼šã‚³ã‚¢ãƒ‡ãƒ¼ã‚¿ã‚»ãƒƒãƒˆã®æ¡ˆå†…ï¼S3ãƒŸãƒ©ãƒ¼ã¯500pxãƒ»å¤§ãã„ç‰ˆã¯ Flickr ã‹ã‚‰å–å¾—ã€ã¨æ˜è¨˜ã€‚
The Multimedia Commons Initiative

Flickr API flickr.photos.getExifï¼šEXIFï¼ˆä¾‹ï¼šFocalLengthIn35mmFormatã€ExifImageWidth/Height ç­‰ï¼‰å–å¾—ã€‚

YFCC100M è«–æ–‡ï¼ˆCACM 2016ï¼‰ï¼šãƒ‡ãƒ¼ã‚¿ã‚»ãƒƒãƒˆã®å…¬å¼ãªå¼•ç”¨å…ˆã€‚
The Multimedia Commons Initiative